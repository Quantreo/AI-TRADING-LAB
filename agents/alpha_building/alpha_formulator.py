# ==========================================================
#  ALPHA FORMULATOR AGENT
# ==========================================================
from langchain_core.prompts import ChatPromptTemplate
from typing import Any, Dict, Optional
from pathlib import Path
import yaml
import re
import datetime


class AlphaFormulatorAgent:
    """
    Agent - Alpha Formulator
    ---------------------------------
    Takes ONE alpha_concept (generated by the Ideator)
    and turns it into ONE operational formula expressed in YAML.
    """

    def __init__(self, llm: Any):
        """
        Args:
            llm: The language model used for formula generation.
        """
        self.llm = llm
        self.prompt_template = self._build_prompt()

    # ------------------------------------------------------------------
    def _build_prompt(self) -> ChatPromptTemplate:
        """
        Build the prompt that instructs the model to transform ONE alpha_concept
        into ONE alpha_formula YAML document.

        The output schema is strict:
        - No markdown
        - No code fences
        - Exactly one YAML document
        - Root keys: alpha_formula, meta
        """
        return ChatPromptTemplate.from_messages([
            (
                "system",
                "You are a senior quantitative researcher. You receive ONE alpha_concept YAML "
                "and must convert it into ONE concrete alpha formula. Output YAML only.\n\n"
                "Rules:\n"
                "- Output exactly ONE YAML document. No markdown. No code fences.\n"
                "- Root keys: 'alpha_formula' and 'meta'.\n"
                "- Use only simple math and standard transforms:\n"
                "  +, -, *, /, abs(), zscore(x), rank(x), ema(x, n), sma(x, n), std(x, n), lag(x, n)\n"
                "- Use features listed in concept.related_features.\n"
                "- Keep formulas parsimonious (2 or 3 terms plus optional conditioning).\n"
                "- Reject or strip any token starting with future_.\n\n"
                "Required YAML schema:\n"
                "alpha_formula:\n"
                "  name: <short formula name>\n"
                "  formula: <expression>\n"
                "  conditioning: <boolean expression or null>\n"
            ),
            (
                "user",
                "Here is the alpha_concept:\n\n{concept_yaml}\n\n"
                "Return ONE YAML document following the schema above. No markdown, no fences."
            )
        ])

    # ------------------------------------------------------------------
    def formulate_alpha(self, concept: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """
        Convert the alpha_concept into a concrete alpha_formula YAML.

        Steps:
        - Dump concept to YAML
        - Send it to the model through the prompt
        - Clean model output (remove code fences)
        - Parse YAML
        - Validate schema
        - Attach metadata
        """
        concept_yaml = yaml.safe_dump(concept, sort_keys=False)
        messages = self.prompt_template.format_messages(concept_yaml=concept_yaml)
        response = self.llm.invoke(messages)
        raw_output = response.content.strip()

        # Remove unwanted markdown-like artifacts
        cleaned = re.sub(r"^```[a-zA-Z]*\s*", "", raw_output).strip()
        cleaned = re.sub(r"```$", "", cleaned).strip()

        try:
            parsed = yaml.safe_load(cleaned)

            # If the model returns a list, pick the first dict containing an alpha_formula
            if isinstance(parsed, list):
                parsed = next((d for d in parsed if isinstance(d, dict) and "alpha_formula" in d), None)

            # Validate structure
            if not isinstance(parsed, dict) or "alpha_formula" not in parsed:
                raise ValueError("Missing 'alpha_formula' at root level.")

            af = parsed["alpha_formula"]
            if not isinstance(af, dict) or not af.get("formula"):
                raise ValueError("Invalid or empty 'formula' field.")

            # Use concept name as formula name fallback
            concept_name = concept.get("alpha_concept", {}).get("name") or "unnamed_formula"
            parsed["alpha_formula"]["name"] = concept_name

            # Fill metadata
            parsed.setdefault("meta", {})
            parsed["meta"]["concept_name"] = concept_name

            print("[INFO] Alpha formula parsed successfully.")
            return parsed

        except Exception as e:
            # Save raw output for debugging
            Path("debug_alpha_formulator_output.yaml").write_text(raw_output, encoding="utf-8")
            print(f"[ERROR] Failed to parse YAML: {e}")
            return None

    # ------------------------------------------------------------------
    def save(self, alpha_yaml: Dict[str, Any], output_dir: Path, basename: Optional[str] = None):
        """
        Save the generated alpha_formula YAML to the output directory.

        Args:
            alpha_yaml: Parsed YAML document containing the formula.
            output_dir: Directory where the formula will be stored.
            basename: Optional custom filename (without timestamp).
        """
        output_dir.mkdir(parents=True, exist_ok=True)

        if basename:
            out_path = output_dir / f"{basename}.yaml"
        else:
            ts = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
            name = alpha_yaml.get("alpha_formula", {}).get("name", "unnamed_formula")
            name = re.sub(r"[^a-zA-Z0-9_-]+", "_", name).strip("_") or "unnamed_formula"
            out_path = output_dir / f"{name}_{ts}.yaml"

        with open(out_path, "w", encoding="utf-8") as f:
            yaml.safe_dump(alpha_yaml, f, sort_keys=False)

        print(f"[SAVE] Alpha formula saved to: {out_path}")

from langchain_core.prompts import ChatPromptTemplate
from pathlib import Path
from typing import Any, Dict, Optional
import yaml
import re


class FeatureDSRObserver:
    """
    Agent - Feature DSR Observer
    --------------------------------
    Analyzes a raw YAML file containing statistical relationships
    (correlation, mutual information, etc.) and formulates a
    DSR observation (Definition, Stability, Robustness).
    """

    def __init__(self, llm: Any):
        self.llm = llm
        self.prompt_template = self._build_prompt()

    # ------------------------------------------------------------------
    def _build_prompt(self) -> ChatPromptTemplate:
        """Builds the LangChain prompt used to infer the DSR for a future_* target."""
        return ChatPromptTemplate.from_messages([
            (
                "system",
                "You are a senior quantitative researcher specializing in systematic trading. "
                "You analyze YAML files describing statistical relationships (correlations, mutual information, etc.) "
                "between a **target variable** (usually prefixed with 'future_') and several related explanatory features.\n\n"
                "Your goal is to produce a professional, audit-grade DSR (Definition‚ÄìStability‚ÄìRobustness) report for this target. "
                "Write in a factual, analytical, and assertive tone. Avoid speculative expressions such as 'likely', 'appears', or 'seems'. "
                "Always use numeric metrics (means, std, crossings, dispersion, etc.) from the YAML when describing stability or robustness.\n\n"
                "Be realistic and data-driven, do not overstate relationships or interpret weak correlations as strong evidence. Focus strictly on what the data supports."
                "Never assume a time unit (minutes, hours, days) for horizons. "
                "Always express them as N-period windows, e.g., ‚Äòover a 120-period horizon‚Äô instead of ‚Äò120-minute‚Äô.\n\n"
                "In addition, classify the target by adding a 'tag' field representing its functional family. "
                "The tag must be chosen **strictly** from the following list:\n"
                "['volatility', 'trend', 'mean_reversion', 'tail_risk', 'distribution_shape', "
                "'volume', 'price_structure', 'regime', 'microstructure', 'cross_asset'].\n\n"
                "Guidelines:\n"
                "1. Definition ‚Äì Describe precisely what the target measures or reacts to, "
                "using quantitative and domain-specific language.\n"
                "2. Stability ‚Äì Explain under which regimes or assets the relationships with its related features remain consistent. "
                "Include numeric indicators (std, crossings, etc.). If you do not have enough info (only one asset, no data over different regimes, no crossing data...)\n"
                "3. Robustness ‚Äì Quantify how generalizable these relationships are across assets or horizons, "
                "using metrics such as dispersion or correlation strength.\n\n"
                "If correlation and mutual information refer to the same family of features "
                "(e.g., rs_vol_* or tail_returns_*), interpret the relation as structurally robust. "
                "If they differ significantly, mention limited robustness.\n\n"
                "Output strictly valid YAML with the following structure:\n"
                "target: <target_name>\n"
                "tag: <one_of_the_allowed_tags>\n"
                "related_features: [<list of main related features extracted from YAML>]\n"
                "dsr_observation:\n"
                "  definition: <quantitative description of what the target measures>\n"
                "  stability: <fact-based summary with numeric indicators>\n"
                "  robustness: <cross-asset or cross-horizon generalization, with numbers>\n"
                "  overall_assessment: <weak/moderate/strong>\n"
                "  comment: <one-line professional synthesis>\n"
                "meta:\n"
                "  comment: Generated by Feature DSR Observer Agent"
                "Formatting rules:\n"
                "- Always wrap any string value containing colons (:), parentheses (), or commas (,) in double quotes.\n"
                "- This applies especially to 'definition', 'stability', 'robustness', 'comment', and 'formula' fields.\n"
                "- Do not include any Markdown, bullet points, or explanatory text outside of the YAML block.\n\n"

            ),
            (
                "user",
                "Here is the target relationship YAML:\n\n{feature_yaml}\n\n"
                "Analyze it carefully and output a single YAML block as instructed above. "
                "Do not include markdown, code fences, or explanations."
            )
        ])

    # ------------------------------------------------------------------
    def _safe_parse_yaml(self, text: str) -> Optional[Dict[str, Any]]:
        """Safely parses the YAML produced by the LLM, automatically fixing common issues."""
        try:
            return yaml.safe_load(text)
        except yaml.YAMLError as e:
            print(f"‚ö†Ô∏è Initial YAML parse failed: {e}. Attempting auto-fix...")

            # Add quotes around text fields that might cause YAML parsing errors
            fixed = re.sub(r'(?m)^( *comment:)(?!\s*["\']).*', lambda m: f'{m.group(1)} "{m.group(0).split(":",1)[1].strip()}"', text)
            fixed = re.sub(r'(?m)^( *formula:)(?!\s*["\']).*', lambda m: f'{m.group(1)} "{m.group(0).split(":",1)[1].strip()}"', fixed)
            fixed = re.sub(r'(?m)^( *definition:)(?!\s*["\']).*', lambda m: f'{m.group(1)} "{m.group(0).split(":",1)[1].strip()}"', fixed)
            fixed = re.sub(r'(?m)^( *stability:)(?!\s*["\']).*', lambda m: f'{m.group(1)} "{m.group(0).split(":",1)[1].strip()}"', fixed)
            fixed = re.sub(r'(?m)^( *robustness:)(?!\s*["\']).*', lambda m: f'{m.group(1)} "{m.group(0).split(":",1)[1].strip()}"', fixed)

            try:
                return yaml.safe_load(fixed)
            except yaml.YAMLError as e2:
                print(f"‚ùå Auto-fix failed: {e2}")
                debug_path = Path("debug_dsr_observer_output.yaml")
                with open(debug_path, "w", encoding="utf-8") as f:
                    f.write(text)
                print(f"üß© Raw model output saved to {debug_path.resolve()}")
                return None

    # ------------------------------------------------------------------
    def analyze(self, feature_yaml: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Analyzes a raw YAML file and generates a DSR observation."""
        yaml_str = yaml.safe_dump(feature_yaml, sort_keys=False)
        messages = self.prompt_template.format_messages(feature_yaml=yaml_str)
        response = self.llm.invoke(messages)
        raw_output = response.content.strip()

        # Clean up potential code fences or artifacts
        cleaned = re.sub(r"^```[a-zA-Z]*\s*", "", raw_output)
        cleaned = re.sub(r"```$", "", cleaned).strip()

        try:
            parsed = self._safe_parse_yaml(cleaned)
            if not isinstance(parsed, dict):
                raise ValueError("Parsed output is not a dictionary.")
            feature_name = parsed.get("feature", "unknown")
            print(f"‚úÖ DSR observation generated for {feature_name}")
            return parsed
        except Exception as e:
            print(f"‚ùå Failed to parse YAML: {e}")
            debug_path = Path("debug_dsr_observer_output.yaml")
            with open(debug_path, "w", encoding="utf-8") as f:
                f.write(raw_output)
            print(f"üß© Raw model output saved to {debug_path.resolve()}")
            return None

    # ------------------------------------------------------------------
    def save(self, dsr_yaml: Dict[str, Any], output_dir: Path, feature_name: str):
        """Saves the DSR YAML to disk."""
        output_dir.mkdir(parents=True, exist_ok=True)
        out_path = output_dir / f"{feature_name}_dsr.yaml"
        with open(out_path, "w", encoding="utf-8") as f:
            yaml.safe_dump(dsr_yaml, f, sort_keys=False)
        print(f"üíæ Saved DSR observation to: {out_path}")
        return out_path

from datetime import datetime

from langchain_core.prompts import ChatPromptTemplate
from pathlib import Path
from typing import Any, Dict, List, Optional
import yaml
import re


class StrategyBuilder:
    """
    Strategy Builder
    ----------------
    This agent generates an entire systematic trading strategy in a single YAML document.
    Responsibilities:
      1) build_strategy(alpha_list) -> returns the full strategy YAML as a dict.
      2) save(strategy_yaml, output_dir) -> writes the YAML to disk.
    """


    def __init__(self, llm: Any):

        self.llm = llm
        self.prompt_template = self._build_prompt()

    # ------------------------------------------------------------------
    # PROMPT (strict, short, YAML-only)
    # ------------------------------------------------------------------
    def _build_prompt(self) -> ChatPromptTemplate:
        """
        Strategy Builder Prompt
        Generates a full strategy YAML with:
        - long_entry
        - short_entry
        - exit
        - position_sizing

        All constraints are enforced by the prompt, not by code.
        """

        system = (
            "You are a senior quantitative strategist. Your task is to build one small but realistic "
            "systematic trading strategy from a list of alpha YAML files.\n\n"

            "OUTPUT FORMAT:\n"
            "Return exactly ONE YAML document. No markdown. No prose. No code fences. No explanations outside YAML.\n\n"

            "SCHEMA (FOLLOW EXACTLY):\n"
            "strategy:\n"
            "  name: <short strategy name>\n\n"
            "  long_entry:\n"
            "    logic: <one-line description>\n"
            "    expression: <boolean expression>\n"
            "    identifiers_used: [<id1>, <id2>, ...]\n"
            "    comment: <operational note>\n\n"
            "  short_entry:\n"
            "    logic: <one-line description>\n"
            "    expression: <boolean expression>\n"
            "    identifiers_used: [<id1>, <id2>, ...]\n"
            "    comment: <operational note>\n\n"
            "  exit:\n"
            "    logic: <one-line description>\n"
            "    expression: <boolean expression referencing days_since_entry and pnl_since_entry>\n"
            "    parameters:\n"
            "      max_duration: <int>\n"
            "      stop_loss: <float>\n"
            "      take_profit: <float>\n"
            "    identifiers_used: [<id1>, <id2>, ...]\n"
            "    comment: <operational note>\n\n"
            "  position_sizing:\n"
            "    logic: <one-line description>\n"
            "    expression: <formula that returns a position size fraction between 0 and max_per_asset>\n"
            "    parameters:\n"
            "      max_per_asset: <float between 0.0 and 0.06>\n"
            "      base_risk_fraction: <float between 0.0 and 0.02>\n"
            "    identifiers_used: [<id1>, <id2>, ...]\n"
            "    comment: <operational note>\n\n"
            "meta:\n"
            "  source_alphas: [<filenames>]\n"
            "  comment: Generated by StrategyBuilder\n\n"

            "GENERAL RULES:\n"
            "- Use ONLY identifiers that appear literally in the provided alpha YAMLs. Do not invent new identifiers.\n"
            "- Never use anything starting with 'future_'.\n"
            "- You may use simple arithmetic (+, -, *, /) and zscore(id, N) for normalization.\n"
            "- Prefer window lengths N that already appear in the alpha YAMLs. If several exist, reuse a small set consistently.\n"
            "- If no window length is visible in the alphas, you may use 20 or 50 but keep them consistent inside the strategy.\n"
            "- If a scalar contains ':', '#', '<' or '>', wrap it in double quotes.\n\n"

            "ENTRY RULES (LONG AND SHORT):\n"
            "- Build TWO directional blocks: long_entry and short_entry.\n"
            "- For entry conditions, prefer identifiers whose names suggest directional information, such as returns, ret, momentum, trend, carry, skew, slope.\n"
            "- Do NOT base both entries solely on pure risk metrics like rs_vol_*, tail_vol_*, log_vol_* without any directional component.\n"
            "- Volatility or risk identifiers may be used as filters, for example to avoid extreme regimes, but not as the only driver of direction.\n"
            "- long_entry and short_entry expressions must not be identical. They must encode genuinely opposite or complementary directional conditions.\n"
            "- Do not use trade-state identifiers in entries: days_since_entry, pnl_since_entry, entry_price, open_price, position, "
            "stop_level, take_profit_level, unrealized_pnl are forbidden in long_entry and short_entry.\n"
            "- Entry expressions must be simple boolean conditions that a human can understand in one line.\n\n"

            "EXIT RULES:\n"
            "- Exit must include parameters: max_duration, stop_loss, take_profit.\n"
            "- stop_loss and take_profit are positive fractions of capital or price, typically between 0.005 and 0.05.\n"
            "- The expression must mirror these parameters exactly using days_since_entry and pnl_since_entry, for example:\n"
            "  days_since_entry >= max_duration or pnl_since_entry <= -stop_loss or pnl_since_entry >= take_profit\n"
            "- You may optionally add one extra condition involving a normalized risk metric, for example zscore(rs_vol_*, N), "
            "but keep the exit expression short.\n"
            "- Do not mix fixed pnl_since_entry thresholds with complex volatility scaled pnl in the same expression.\n\n"

            "POSITION SIZING RULES:\n"
            "- position_sizing must produce a size fraction between 0 and max_per_asset.\n"
            "- Use volatility or risk identifiers (for example realized volatility, regime indicators) to reduce size when risk is high.\n"
            "- base_risk_fraction should be small, typically between 0.005 and 0.02.\n"
            "- max_per_asset must be ≤ 0.06.\n"
            "- A typical expression could be of the form:\n"
            "  base_risk_fraction * (target_vol / rs_vol_*) clipped at max_per_asset\n"
            "  expressed in a single line using simple arithmetic. You may refer to min(a, b) conceptually inside the expression if needed.\n"
            "- Do not return negative sizes and do not exceed max_per_asset in the expression.\n\n"

            "QUALITY RULES:\n"
            "- Avoid trivial expressions like x > 0 or x < 0 unless clearly meaningful in context.\n"
            "- Avoid using only relationships between different volatility metrics as entry triggers. Direction must come from signals that are plausibly linked to price direction.\n"
            "- Keep each expression short enough to be understandable and auditable.\n\n"

            "TASK:\n"
            "Use the alpha YAMLs below as read-only context. Extract identifiers and any existing window lengths from them. "
            "Then build one coherent, realistic strategy that follows the schema and all rules above. "
            "Do not add fields. Do not add markdown. Do not add any explanation outside the YAML document."
        )

        return ChatPromptTemplate.from_messages([
            ("system", system),
            (
                "user",
                "Alpha YAMLs (read-only context, extract identifiers and window lengths only):\n\n{alpha_yamls}\n\n"
                "Generate exactly ONE YAML document that matches the schema above. No markdown. No extra text."
            ),
        ])

    # ------------------------------------------------------------------
    # GENERATE
    # ------------------------------------------------------------------
    def build_strategy(self, alpha_list: List[Dict[str, Any]]) -> Optional[Dict[str, Any]]:
        """
        Minimal generation:
          - dump alphas to text
          - call LLM with strict prompt
          - strip code fences
          - yaml.safe_load
        """
        alpha_str = yaml.safe_dump_all(alpha_list, sort_keys=False)

        messages = self.prompt_template.format_messages(alpha_yamls=alpha_str)
        resp = self.llm.invoke(messages)
        raw = resp.content.strip()

        # remove code fences if any
        cleaned = re.sub(r"^```[a-zA-Z]*\s*", "", raw)
        cleaned = re.sub(r"```$", "", cleaned).strip()

        try:
            parsed = yaml.safe_load(cleaned)
            if not isinstance(parsed, dict):
                raise ValueError("Model did not return a YAML mapping.")
            return parsed
        except Exception as e:
            print(f"❌ Failed to parse YAML: {e}")
            # keep the raw for debugging
            return None

    # ------------------------------------------------------------------
    # SAVE
    # ------------------------------------------------------------------
    def save(self, strategy_yaml: Dict[str, Any], output_dir: Path) -> Path:
        """
        Save the generated YAML strategy using its `name` field and a timestamp
        to avoid overwriting previous files.
        """
        output_dir.mkdir(parents=True, exist_ok=True)

        # Extract strategy block name
        base_name = strategy_yaml.get("name", "strategy_block")
        base_name = base_name.replace(" ", "_").lower()

        # Timestamp for uniqueness
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")

        # Final filename
        filename = f"{base_name}_{timestamp}.yaml"
        out_path = output_dir / filename

        # Save YAML
        with open(out_path, "w", encoding="utf-8") as f:
            yaml.safe_dump(strategy_yaml, f, sort_keys=False)

        return out_path
